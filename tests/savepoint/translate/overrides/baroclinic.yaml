C_SW:
  - backend: numpy
    max_error: 5e-2

FVDynamics:
  - backend: numpy
    ignore_near_zero_errors:
      uc: 1e-13
      vc: 1e-13
      mfxd: 1e-3
      mfyd: 1e-3
      cxd: 1e-3
      cyd: 1e-3

DynCore:
  - backend: numpy
    ignore_near_zero_errors:
      uc: 1e-13
      vc: 1e-13
      mfxd: 1e-3
      mfyd: 1e-3
      cxd: 1e-3
      cyd: 1e-3

D_SW:
  - backend: numpy
    ignore_near_zero_errors:
      divgdd: 1e-20
      ucd: 1e-20
      vcd: 1e-20
      delpcd: 1e-15

DivergenceDamping:
  - backend: numpy
    ignore_near_zero_errors:
      vort: 6e-8
      delpc: 1e-15

GFSPhysicsDriver:
  - backend: numpy
    max_error: 1e-10
  - backend: gtx86
    max_error: 1e-10
  - backend: gtc:gt:cpu_ifirst
    max_error: 1e-10

# On GPU u/v wind tendencies seems to diverge in computation from numpy equivalent.
# Because they are added to u/v in the dycore and their error magnitude (<e-8) is small in regards to 
# wind magnitude overall (0-3), we have a "high" threshold.
# Arithmetic GPU bug logged in: DSL-1019
Microph:
  - backend: numpy
    max_error: 1e-10
  - backend: gtx86
    max_error: 1e-12
  - backend: gtc:gt:cpu_ifirst
    max_error: 1e-12
  - backend: gtcuda
    ignore_near_zero_errors:
      mph_udt: 3e-8
      mph_vdt: 3e-8
  - backend: gtc:cuda
    ignore_near_zero_errors:
      mph_udt: 3e-8
      mph_vdt: 3e-8
  - backend: gtc:gt:gpu
    ignore_near_zero_errors:
      mph_udt: 3e-8
      mph_vdt: 3e-8

FillGFS:
  - backend: gtx86
    ignore_near_zero_errors:
      IPD_qvapor: 9.9e-8


FVUpdatePhys:
  - backend: numpy
    max_error: 4e-5
